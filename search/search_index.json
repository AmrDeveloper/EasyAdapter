{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Easy Adapter Android Annotation Processor library to generate adapter class easily from your model with a lot of customization Features Everything done in Compile time. Supports Kapt and KSP processors. Supports List, Recycler and Array Adapters. Supports Paging2 and Paging3 Adapters. Supports Expandable List Adapter. Supports image loading with Picasso, Glide and Coil. Supports generating DiffUtil ItemCallback. Supports generating refresh data method for RecyclerAdapter. Supports generating listeners. Supports type checking when using annotation with invalid data type. Supports default and custom name for the generated Adapter class. Show clear warns and errors. We are open to any new feature request, bug fix request, and pull request.","title":"Home"},{"location":"#easy-adapter","text":"Android Annotation Processor library to generate adapter class easily from your model with a lot of customization","title":"Easy Adapter"},{"location":"#features","text":"Everything done in Compile time. Supports Kapt and KSP processors. Supports List, Recycler and Array Adapters. Supports Paging2 and Paging3 Adapters. Supports Expandable List Adapter. Supports image loading with Picasso, Glide and Coil. Supports generating DiffUtil ItemCallback. Supports generating refresh data method for RecyclerAdapter. Supports generating listeners. Supports type checking when using annotation with invalid data type. Supports default and custom name for the generated Adapter class. Show clear warns and errors. We are open to any new feature request, bug fix request, and pull request.","title":"Features"},{"location":"how_to_use/","text":"How to use? EasyAdapter has 3 types of annotations that help you to generate your adapter Adapters Annotations: Used to select the Adapter type and set the list item for it. Binds Annotations: Used to bind this field value into view setter. Listeners: Used to annotate the model class to select which listener you want to generate. Example const val appId = \"com.amrdeveloper.app\" const val modelListItem = \"list_item_model\" @BindListener(ListenerType.OnClick) @BindListener(ListenerType.OnLongClick) @BindListener(ListenerType.OnClick, \"model_name\") @ListAdapter(appId, modelListItem) data class Model ( @BindText(\"model_name\") val name : String, @BindImage(ImageLoader.COIL, \"model_avatar\") val avatarUrl : String, @BindAlpha(\"model_avatar\") val avatarAlpha : Float, ) Now after you build the project you will find a generated adapter called ModelListAdapter , this default name come from the model class name ( Model ) + the adapter name ( ListAdapter ), you can change it easily by passing your custom name in the adapter Annotation, And now you can use this adapter like any other normal adapter val adapter = ModelListAdapter() recyclerView.adapter = adapter You can find a full documentation and example for each annotation in it section.","title":"How to use"},{"location":"how_to_use/#how-to-use","text":"EasyAdapter has 3 types of annotations that help you to generate your adapter Adapters Annotations: Used to select the Adapter type and set the list item for it. Binds Annotations: Used to bind this field value into view setter. Listeners: Used to annotate the model class to select which listener you want to generate.","title":"How to use?"},{"location":"how_to_use/#example","text":"const val appId = \"com.amrdeveloper.app\" const val modelListItem = \"list_item_model\" @BindListener(ListenerType.OnClick) @BindListener(ListenerType.OnLongClick) @BindListener(ListenerType.OnClick, \"model_name\") @ListAdapter(appId, modelListItem) data class Model ( @BindText(\"model_name\") val name : String, @BindImage(ImageLoader.COIL, \"model_avatar\") val avatarUrl : String, @BindAlpha(\"model_avatar\") val avatarAlpha : Float, ) Now after you build the project you will find a generated adapter called ModelListAdapter , this default name come from the model class name ( Model ) + the adapter name ( ListAdapter ), you can change it easily by passing your custom name in the adapter Annotation, And now you can use this adapter like any other normal adapter val adapter = ModelListAdapter() recyclerView.adapter = adapter You can find a full documentation and example for each annotation in it section.","title":"Example"},{"location":"install/","text":"How to install? Add the following line to app-level build.gradle file, in dependencies scope: plugins { // kapt or ksp id 'kotlin-kapt' id (\"com.google.devtools.ksp\") version \"1.6.10-1.0.2\" } //Make IDE aware of generated code if you use ksp kotlin { sourceSets.debug { kotlin.srcDir(\"build/generated/ksp/debug/kotlin\") } } dependencies { implementation \"io.github.amrdeveloper:easyadapter:1.1.1\" // kapt or ksp ksp \"io.github.amrdeveloper:easyadapter-compiler:1.1.1\" }","title":"Install"},{"location":"install/#how-to-install","text":"Add the following line to app-level build.gradle file, in dependencies scope: plugins { // kapt or ksp id 'kotlin-kapt' id (\"com.google.devtools.ksp\") version \"1.6.10-1.0.2\" } //Make IDE aware of generated code if you use ksp kotlin { sourceSets.debug { kotlin.srcDir(\"build/generated/ksp/debug/kotlin\") } } dependencies { implementation \"io.github.amrdeveloper:easyadapter:1.1.1\" // kapt or ksp ksp \"io.github.amrdeveloper:easyadapter-compiler:1.1.1\" }","title":"How to install?"},{"location":"annotations/adapters/","text":"Adapter Annotations: @ArrayAdapter Used to generate ArrayAdapter Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name customClassName(optional): custom name for the generated file Example: @ArrayAdapter(\"com.amrdeveloper.app\", \"list_item_model\") data class Model @RecyclerAdapter Used to generate RecyclerAdapter Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name customClassName(optional): custom name for the generated file Example: @RecyclerAdapter(\"com.amrdeveloper.app\", \"list_item_model\") data class Model @ListAdapter Used to generate ListAdapter Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name diffUtilContent(require): field name that will used in DiffUtil.ItemCallback customClassName(optional): custom name for the generated file Example: @ListAdapter(\"com.amrdeveloper.app\", \"list_item_model\", \"name\") data class Model ( val name : String ) @PagingDataAdapter Used to generate PagingDataAdapter (Paging3) Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name diffUtilContent(require): field name that will used in DiffUtil.ItemCallback customClassName(optional): custom name for the generated file Example: @PagingDataAdapter(\"com.amrdeveloper.app\", \"list_item_model\", \"name\") data class Model ( val name : String ) @PagedListAdapter Used to generate PagedListAdapter (Paging2) Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name diffUtilContent(require): field name that will used in DiffUtil.ItemCallback customClassName(optional): custom name for the generated file Example: @PagedListAdapter(\"com.amrdeveloper.app\", \"list_item_model\", \"name\") data class Model ( val name : String ) @ExpandableAdapter Used to generate BaseExpandableListAdapter. Parameters: appPackageName(require): Take the app package name customClassName(optional): custom name for the generated file the model must have a map of Group model and a list of child model annotated with @BindExpandableMap the group and child models must annotated with @BindExpandable Example: @BindExpandable(\"list_item_model1\") data class Model1 @BindExpandable(\"list_item_model2\") data class Model2 @ExpandableAdapter(\"com.amrdeveloper.app\") data class ExpandableModel ( @BindExpandableMap val data: Map<Model1, List<Model2>> )","title":"Adapters"},{"location":"annotations/adapters/#adapter-annotations","text":"","title":"Adapter Annotations:"},{"location":"annotations/adapters/#arrayadapter","text":"Used to generate ArrayAdapter Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name customClassName(optional): custom name for the generated file Example: @ArrayAdapter(\"com.amrdeveloper.app\", \"list_item_model\") data class Model","title":"@ArrayAdapter"},{"location":"annotations/adapters/#recycleradapter","text":"Used to generate RecyclerAdapter Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name customClassName(optional): custom name for the generated file Example: @RecyclerAdapter(\"com.amrdeveloper.app\", \"list_item_model\") data class Model","title":"@RecyclerAdapter"},{"location":"annotations/adapters/#listadapter","text":"Used to generate ListAdapter Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name diffUtilContent(require): field name that will used in DiffUtil.ItemCallback customClassName(optional): custom name for the generated file Example: @ListAdapter(\"com.amrdeveloper.app\", \"list_item_model\", \"name\") data class Model ( val name : String )","title":"@ListAdapter"},{"location":"annotations/adapters/#pagingdataadapter","text":"Used to generate PagingDataAdapter (Paging3) Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name diffUtilContent(require): field name that will used in DiffUtil.ItemCallback customClassName(optional): custom name for the generated file Example: @PagingDataAdapter(\"com.amrdeveloper.app\", \"list_item_model\", \"name\") data class Model ( val name : String )","title":"@PagingDataAdapter"},{"location":"annotations/adapters/#pagedlistadapter","text":"Used to generate PagedListAdapter (Paging2) Parameters: appPackageName(require): Take the app package name layoutId(require): the list item layout name diffUtilContent(require): field name that will used in DiffUtil.ItemCallback customClassName(optional): custom name for the generated file Example: @PagedListAdapter(\"com.amrdeveloper.app\", \"list_item_model\", \"name\") data class Model ( val name : String )","title":"@PagedListAdapter"},{"location":"annotations/adapters/#expandableadapter","text":"Used to generate BaseExpandableListAdapter. Parameters: appPackageName(require): Take the app package name customClassName(optional): custom name for the generated file the model must have a map of Group model and a list of child model annotated with @BindExpandableMap the group and child models must annotated with @BindExpandable Example: @BindExpandable(\"list_item_model1\") data class Model1 @BindExpandable(\"list_item_model2\") data class Model2 @ExpandableAdapter(\"com.amrdeveloper.app\") data class ExpandableModel ( @BindExpandableMap val data: Map<Model1, List<Model2>> )","title":"@ExpandableAdapter"},{"location":"annotations/binds/","text":"Binds Annotations: @BindText Used to annotate String field to use it as a text for TextView Parameters: viewId: the id of the TextView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindText(\"name\") val name : String @BindText(\"name\", condition = \"item.name.isNotEmpty()\") val name : String @BindImage Used to annotate String which represent the image path to load it into ImageView Parameters: viewId: the id of the ImageView loader: can be ImageLoader.PICASSO, ImageLoader.GLIDE, ImageLoader.COIL condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindImage(ImageLoader.COIL, \"main_background\") val wallpaper : String @BindImage(ImageLoader.COIL, \"main_background\", \"item.wallpaper.isNotEmpty()\") val wallpaper : String @BindGif Used to annotate integer which represent the gif raw file name to load it into ImageView Parameters: viewId: the id of the ImageView loader: can be GifLoader.GLIDE, GifLoader.COIL condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindImage(GifLoader.COIL, \"main_background\") val wallpaper : Int @BindImage(GifLoader.COIL, \"main_background\", \"item.wallpaper.isNotEmpty()\") val wallpaper : Int @BindImageRes Used to annotate int which represent the resource id to used as an resource for ImageView Parameters: viewId: the id of the ImageView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindImageRes(\"main_background\") val wallpaper : Int = R.drawable.main_background @BindImageRes(\"main_background\", \"item.wallpaper != -1\") val wallpaper : Int = R.drawable.main_background @BindBackgroundRes Used to annotate int which represent the resource id to used as an background for ImageView Parameters: viewId: the id of the ImageView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindBackgroundRes(\"main_background\") val wallpaper : Int = R.drawable.main_background @BindBackgroundRes(\"main_background\", \"item.wallpaper != -1\") val wallpaper : Int = R.drawable.main_background @BindBackgroundColor Used to annotate int which represent the color to used as an background color for ImageView Parameters: - viewId: the id of the ImageView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindBackgroundRes(\"main_background\") val background : Int = Color.BLACK @BindBackgroundRes(\"main_background\", \"item.wallpaper != -1\") val background : Int = Color.BLACK @BindAlpha Used to annotate floats which represent the alpha value to used with View Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindAlpha(\"main_background\") val alphaVal : Float @BindAlpha(\"main_background\", \"item.alphaVal > 0\") val alphaVal : Float @BindVisibility Used to annotate integers which represent View visibility Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindVisibility(\"main_background\") val backgroundVisibility : Int = View.GONE @BindVisibility(\"main_background\", \"item.background.isEmpty()\") val backgroundVisibility : Int = View.GONE @BindTextColor Used to annotate integers which represent Text color Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindTextColor(\"user_name\") val titleColor : Int = Color.BLACK @BindTextColor(\"user_name\", \"item.title.isEmpty()\") val titleColor : Int = Color.BLACK @BindLottieRaw Used to annotate integers which represent lottie animation raw res id Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindLottieRaw(\"lottie_view\") val lottieAnimation : Int = R.raw.animation_file @BindLottieRaw(\"lottie_view\", \"item.state\") val lottieAnimation : Int = R.raw.animation_file @BindLottieUrl Used to annotate integers which represent lottie animation url Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindLottieUrl(\"lottie_view\") val lottieAnimationUrl : String @BindLottieUrl(\"lottie_view\", \"item.state\") val lottieAnimationUrl : String @BindLottieAsset Used to annotate integers which represent lottie animation asset name Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindLottieAsset(\"lottie_view\") val lottieAnimationAsset : String @BindLottieAsset(\"lottie_view\", \"item.state\") val lottieAnimationAsset : String","title":"Binds"},{"location":"annotations/binds/#binds-annotations","text":"","title":"Binds Annotations:"},{"location":"annotations/binds/#bindtext","text":"Used to annotate String field to use it as a text for TextView Parameters: viewId: the id of the TextView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindText(\"name\") val name : String @BindText(\"name\", condition = \"item.name.isNotEmpty()\") val name : String","title":"@BindText"},{"location":"annotations/binds/#bindimage","text":"Used to annotate String which represent the image path to load it into ImageView Parameters: viewId: the id of the ImageView loader: can be ImageLoader.PICASSO, ImageLoader.GLIDE, ImageLoader.COIL condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindImage(ImageLoader.COIL, \"main_background\") val wallpaper : String @BindImage(ImageLoader.COIL, \"main_background\", \"item.wallpaper.isNotEmpty()\") val wallpaper : String","title":"@BindImage"},{"location":"annotations/binds/#bindgif","text":"Used to annotate integer which represent the gif raw file name to load it into ImageView Parameters: viewId: the id of the ImageView loader: can be GifLoader.GLIDE, GifLoader.COIL condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindImage(GifLoader.COIL, \"main_background\") val wallpaper : Int @BindImage(GifLoader.COIL, \"main_background\", \"item.wallpaper.isNotEmpty()\") val wallpaper : Int","title":"@BindGif"},{"location":"annotations/binds/#bindimageres","text":"Used to annotate int which represent the resource id to used as an resource for ImageView Parameters: viewId: the id of the ImageView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindImageRes(\"main_background\") val wallpaper : Int = R.drawable.main_background @BindImageRes(\"main_background\", \"item.wallpaper != -1\") val wallpaper : Int = R.drawable.main_background","title":"@BindImageRes"},{"location":"annotations/binds/#bindbackgroundres","text":"Used to annotate int which represent the resource id to used as an background for ImageView Parameters: viewId: the id of the ImageView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindBackgroundRes(\"main_background\") val wallpaper : Int = R.drawable.main_background @BindBackgroundRes(\"main_background\", \"item.wallpaper != -1\") val wallpaper : Int = R.drawable.main_background","title":"@BindBackgroundRes"},{"location":"annotations/binds/#bindbackgroundcolor","text":"Used to annotate int which represent the color to used as an background color for ImageView Parameters: - viewId: the id of the ImageView condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindBackgroundRes(\"main_background\") val background : Int = Color.BLACK @BindBackgroundRes(\"main_background\", \"item.wallpaper != -1\") val background : Int = Color.BLACK","title":"@BindBackgroundColor"},{"location":"annotations/binds/#bindalpha","text":"Used to annotate floats which represent the alpha value to used with View Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindAlpha(\"main_background\") val alphaVal : Float @BindAlpha(\"main_background\", \"item.alphaVal > 0\") val alphaVal : Float","title":"@BindAlpha"},{"location":"annotations/binds/#bindvisibility","text":"Used to annotate integers which represent View visibility Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindVisibility(\"main_background\") val backgroundVisibility : Int = View.GONE @BindVisibility(\"main_background\", \"item.background.isEmpty()\") val backgroundVisibility : Int = View.GONE","title":"@BindVisibility"},{"location":"annotations/binds/#bindtextcolor","text":"Used to annotate integers which represent Text color Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindTextColor(\"user_name\") val titleColor : Int = Color.BLACK @BindTextColor(\"user_name\", \"item.title.isEmpty()\") val titleColor : Int = Color.BLACK","title":"@BindTextColor"},{"location":"annotations/binds/#bindlottieraw","text":"Used to annotate integers which represent lottie animation raw res id Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindLottieRaw(\"lottie_view\") val lottieAnimation : Int = R.raw.animation_file @BindLottieRaw(\"lottie_view\", \"item.state\") val lottieAnimation : Int = R.raw.animation_file","title":"@BindLottieRaw"},{"location":"annotations/binds/#bindlottieurl","text":"Used to annotate integers which represent lottie animation url Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindLottieUrl(\"lottie_view\") val lottieAnimationUrl : String @BindLottieUrl(\"lottie_view\", \"item.state\") val lottieAnimationUrl : String","title":"@BindLottieUrl"},{"location":"annotations/binds/#bindlottieasset","text":"Used to annotate integers which represent lottie animation asset name Parameters: viewId: the id of the View condition: a condition to used and apply the bind only if this condition is evaluated to true Examples: @BindLottieAsset(\"lottie_view\") val lottieAnimationAsset : String @BindLottieAsset(\"lottie_view\", \"item.state\") val lottieAnimationAsset : String","title":"@BindLottieAsset"},{"location":"annotations/listeners/","text":"How to add listener? To add listener all you need is to annotated the model class by @BindListener BindListener take 2 information 1 - Listener type which can be OnClick OnLongClick OnTouch OnHover OnCheckedChange OnTextChange OnFocusChange 2 - view id and you can ignore it if you want this listener to be for your list item layout. Examples: To generate OnClickListener for your list item layout @BindListener(ListenerType.OnClick) To generate onClickListener for view with id name @BindListener(ListenerType.OnClick, \"name\") Note that if you have declared the exact same listener more than one time, just one will be generated and the other will be ignored. ```","title":"Listeners"},{"location":"annotations/listeners/#how-to-add-listener","text":"To add listener all you need is to annotated the model class by @BindListener BindListener take 2 information 1 - Listener type which can be OnClick OnLongClick OnTouch OnHover OnCheckedChange OnTextChange OnFocusChange 2 - view id and you can ignore it if you want this listener to be for your list item layout. Examples: To generate OnClickListener for your list item layout @BindListener(ListenerType.OnClick) To generate onClickListener for view with id name @BindListener(ListenerType.OnClick, \"name\") Note that if you have declared the exact same listener more than one time, just one will be generated and the other will be ignored. ```","title":"How to add listener?"},{"location":"contribution/documentation/","text":"Documentation All the documentations are written in Mark Down files in docs directory We use Material MkDocs to generate the website How to edit the docs? Clone the repository git clone https://github.com/amrdeveloper/easyadapter.git Enter the docs directory cd docs Edit the file, you can see the output live on the website using mkdocs serve, mkdocs serve Open docs website locally to see the output. http://127.0.0.1:8000/easyadapter After finishing the modification, commit and make Pull request.","title":"Documentation"},{"location":"contribution/documentation/#documentation","text":"All the documentations are written in Mark Down files in docs directory We use Material MkDocs to generate the website","title":"Documentation"},{"location":"contribution/documentation/#how-to-edit-the-docs","text":"Clone the repository git clone https://github.com/amrdeveloper/easyadapter.git Enter the docs directory cd docs Edit the file, you can see the output live on the website using mkdocs serve, mkdocs serve Open docs website locally to see the output. http://127.0.0.1:8000/easyadapter After finishing the modification, commit and make Pull request.","title":"How to edit the docs?"},{"location":"contribution/report/","text":"Report Issue You're most welcome to report any issue or corner case, but first make sure this issue isn't reported before on the issues list on Github Repository. If it unique, that's very good you should report it by creating new issue and explained when exactly this issue appear and it will be amazing if you can add code example. If you want also to work on this issue, tell us in the end that you can do it and we will start discussion about it. Feel free to share your ideas and hints.","title":"Report Issue"},{"location":"contribution/report/#report-issue","text":"You're most welcome to report any issue or corner case, but first make sure this issue isn't reported before on the issues list on Github Repository. If it unique, that's very good you should report it by creating new issue and explained when exactly this issue appear and it will be amazing if you can add code example. If you want also to work on this issue, tell us in the end that you can do it and we will start discussion about it. Feel free to share your ideas and hints.","title":"Report Issue"},{"location":"contribution/suggestion/","text":"Suggest New Feature I believe that everyone can add new value to EasyAdapter and any contribution will be very helpful. If you see that any part of this tool can be improved, feel free to make new issue with some information for example which part? code, docs...etc and what is your suggestion to improve it? also do you want to work on this suggestion? After submitting your issue we will have a discussion and brainstorm about this suggestion to see what is the best way to implement it.","title":"Suggest Fetaure"},{"location":"contribution/suggestion/#suggest-new-feature","text":"I believe that everyone can add new value to EasyAdapter and any contribution will be very helpful. If you see that any part of this tool can be improved, feel free to make new issue with some information for example which part? code, docs...etc and what is your suggestion to improve it? also do you want to work on this suggestion? After submitting your issue we will have a discussion and brainstorm about this suggestion to see what is the best way to implement it.","title":"Suggest New Feature"},{"location":"contribution/support_new_adapter/","text":"Support new Adapter This page will provide a clear steps on how you can add support for new adapter annotation Step 1: Create new Annotation for this adapter in easyadapter module. @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class NewAdapter ( val appPackageName : String, val layoutId : String, val customClassName : String = \"\", ) Step 2: In easyadapter-compiler module create new class that extend AdapterData class. data class NewAdapterData ( ...override abstract field and method. ...Add any extra fields for your adapter. ) : AdapterData() Step 3: Create parser method for this adapter. fun parseNewAdapter(element: Element) : NewAdapterData { ...Take the needed information from element ...Create and return instance of NewAdapterData with the informations. } Step 4: Create parser method for the KSP Adapter Parser @OptIn(KspExperimental::class, KotlinPoetKspPreview::class) fun parseNewAdapter(classDeclaration: KSClassDeclaration): NewAdapterData { ...Take the needed information from element ...Create and return instance of NewAdapterData with the informations. } Step 5: Create new code generator for your adapter that extend AdapterGenerator class. class NewAdapterGenerator( private val adapterData: NewAdapter ) : AdapterGenerator() { ...override abstract method ...Check Generator Helper to see if you need any helper extension from it ...add helper methods to help you generate code easily } Step 6: Use the parser and generator to create new adapter file, in the default processor. override fun process(annotations: MutableSet<out TypeElement>, environment: RoundEnvironment): Boolean { ... environment.getElementsAnnotatedWith(NewAdapter::class.java).forEach { val adapter = adapterParser.parseNewAdapter(it) generateAdapterSourceFile(adapter, NewAdapterGenerator(adapter)) } } Step 7: Use the parser and generator to create new adapter file, in the KSP Processor. @OptIn(KspExperimental::class, KotlinPoetKspPreview::class) override fun process(resolver: Resolver): List<KSAnnotated> { ... resolver.getSymbolsWithAnnotation(NewAdapter::class.java.name).forEach { if (it is KSClassDeclaration) { val adapterData = adapterParser.parseNewAdapter(it) val newAdapter = NewAdapterGenerator(adapter).generate() generateAdapterSourceFile(adapter, newAdapter, dependencies) } } } Now you are done, enjoy the new adapter annotation.","title":"Support New Adapter"},{"location":"contribution/support_new_adapter/#support-new-adapter","text":"This page will provide a clear steps on how you can add support for new adapter annotation Step 1: Create new Annotation for this adapter in easyadapter module. @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.SOURCE) annotation class NewAdapter ( val appPackageName : String, val layoutId : String, val customClassName : String = \"\", ) Step 2: In easyadapter-compiler module create new class that extend AdapterData class. data class NewAdapterData ( ...override abstract field and method. ...Add any extra fields for your adapter. ) : AdapterData() Step 3: Create parser method for this adapter. fun parseNewAdapter(element: Element) : NewAdapterData { ...Take the needed information from element ...Create and return instance of NewAdapterData with the informations. } Step 4: Create parser method for the KSP Adapter Parser @OptIn(KspExperimental::class, KotlinPoetKspPreview::class) fun parseNewAdapter(classDeclaration: KSClassDeclaration): NewAdapterData { ...Take the needed information from element ...Create and return instance of NewAdapterData with the informations. } Step 5: Create new code generator for your adapter that extend AdapterGenerator class. class NewAdapterGenerator( private val adapterData: NewAdapter ) : AdapterGenerator() { ...override abstract method ...Check Generator Helper to see if you need any helper extension from it ...add helper methods to help you generate code easily } Step 6: Use the parser and generator to create new adapter file, in the default processor. override fun process(annotations: MutableSet<out TypeElement>, environment: RoundEnvironment): Boolean { ... environment.getElementsAnnotatedWith(NewAdapter::class.java).forEach { val adapter = adapterParser.parseNewAdapter(it) generateAdapterSourceFile(adapter, NewAdapterGenerator(adapter)) } } Step 7: Use the parser and generator to create new adapter file, in the KSP Processor. @OptIn(KspExperimental::class, KotlinPoetKspPreview::class) override fun process(resolver: Resolver): List<KSAnnotated> { ... resolver.getSymbolsWithAnnotation(NewAdapter::class.java.name).forEach { if (it is KSClassDeclaration) { val adapterData = adapterParser.parseNewAdapter(it) val newAdapter = NewAdapterGenerator(adapter).generate() generateAdapterSourceFile(adapter, newAdapter, dependencies) } } } Now you are done, enjoy the new adapter annotation.","title":"Support new Adapter"},{"location":"contribution/support_new_bind/","text":"Support new Bind This page will provide a clear steps on how you can add support for new binds Step 1: Create new Annotation for this bind in easyadapter module. @Target(AnnotationTarget.FIELD) @Retention(AnnotationRetention.SOURCE) annotation class BindNew ( val viewId : String, ...Extra fields if needed ) Step 2: In easyadapter-compiler module create new class that extend BindingData class. data class BindingNewData ( ...Override abstract fields. ...Add Extra fields if you need them. ) : BindingData() { ...Override generateFieldBinding method to write code generator for this bind } Step 3: Support parsing this bind annotation in Adapter Parser. element.getAnnotation(BindNew::class.java)?.let { ...You can check the annotated field type if needed val binding = BindingNewData(elementName, it.viewId) viewBindingDataList.add(binding) } Step 4: Support parsing this bind annotation in KSP Adapter Parser. if (it.isAnnotationPresent(BindNew::class)) { ...You can check the annotated field type if needed val annotation = it.getAnnotationsByType(BindNew::class).first() val binding = BindingNewData(elementName, annotation.viewId) viewBindingDataList.add(binding) } Now you are done, enjoy the new bind annotation.","title":"Support New Bind"},{"location":"contribution/support_new_bind/#support-new-bind","text":"This page will provide a clear steps on how you can add support for new binds Step 1: Create new Annotation for this bind in easyadapter module. @Target(AnnotationTarget.FIELD) @Retention(AnnotationRetention.SOURCE) annotation class BindNew ( val viewId : String, ...Extra fields if needed ) Step 2: In easyadapter-compiler module create new class that extend BindingData class. data class BindingNewData ( ...Override abstract fields. ...Add Extra fields if you need them. ) : BindingData() { ...Override generateFieldBinding method to write code generator for this bind } Step 3: Support parsing this bind annotation in Adapter Parser. element.getAnnotation(BindNew::class.java)?.let { ...You can check the annotated field type if needed val binding = BindingNewData(elementName, it.viewId) viewBindingDataList.add(binding) } Step 4: Support parsing this bind annotation in KSP Adapter Parser. if (it.isAnnotationPresent(BindNew::class)) { ...You can check the annotated field type if needed val annotation = it.getAnnotationsByType(BindNew::class).first() val binding = BindingNewData(elementName, annotation.viewId) viewBindingDataList.add(binding) } Now you are done, enjoy the new bind annotation.","title":"Support new Bind"},{"location":"contribution/support_new_listener/","text":"Support new Listener This page will provide a clear steps on how you can add support for new listener. Supporting new listener doesn't require new annotation. Step 1: Add new Type to ListenerType enum. enum class ListenerType(val shortName: String) { ... OnNew(\"New\") } Step 2: In easyadapter-compiler module create new class that extend ListenerData class. data class NewListenerData ( ...override abstract field. ) : ListenerData() { ...override abstract method } Step 3: Support parsing this listener type in Adapter Parser. ListenerType.OnNew -> NewListenerData(modelName, it.viewId) Step 4: Support parsing this listener type in KSP Adapter Parser. ListenerType.OnNew -> NewListenerData(modelName, it.viewId) Now you are done, enjoy the new listener type.","title":"Support New Listener"},{"location":"contribution/support_new_listener/#support-new-listener","text":"This page will provide a clear steps on how you can add support for new listener. Supporting new listener doesn't require new annotation. Step 1: Add new Type to ListenerType enum. enum class ListenerType(val shortName: String) { ... OnNew(\"New\") } Step 2: In easyadapter-compiler module create new class that extend ListenerData class. data class NewListenerData ( ...override abstract field. ) : ListenerData() { ...override abstract method } Step 3: Support parsing this listener type in Adapter Parser. ListenerType.OnNew -> NewListenerData(modelName, it.viewId) Step 4: Support parsing this listener type in KSP Adapter Parser. ListenerType.OnNew -> NewListenerData(modelName, it.viewId) Now you are done, enjoy the new listener type.","title":"Support new Listener"}]}